# only use this from within this file or for testing.
# See get_rig_capabilities() ad other functions below.
# Parameters:
# --unhandled: Optional flag that prints all lines from --dump-caps output
#   that have not been handled or ignored on purpose.
# model: Rig model number.
# rigcap_general: Array for overall rig data.
# rigcap_bounds: Array which stores min, max and res values for levels and other values.
# rigcap_features: Array with feature availability information.
# rigcap_ctcss_range: Array that holds valid CTCSS values.
# rigcap_dcs_range: Array that holds valid DCS values.
# rigcap_modes: Array with valid modes.
# rigcap_vfos: Array containing all available VFOs.
# rigcap_dummy_fvo_ops, rigcap_dummy_scan_ops:
#   Arrays that hold VFO and scan operations.
# rigcap_functions, rigcap_levels, rigcap_parameters:
#   Arrays that store get, set or getset functions, levels and parameters.
# rigcap_warnings: Array holding backend warnings.
internal_get_capabilities() {
  local i tmp tmp1 tmp2 tmp3 tmp4 tmp5 tmp6 xxx
  local show_unhandled indentation
  if [[ "$1" == "--unhandled" ]]; then
    show_unhandled=1
    shift 1
  else
    show_unhandled=0
  fi
  # Following is correct as long as parameter $2 names an array variable.
  # shellcheck disable=SC2178
  local -n general=$2 bounds=$3 features=$4 ctcss=$5 dcs=$6 modeslist=$7 vfos=$8 vfo_ops=$9 scan_ops=${10} functions=${11} levels=${12} params=${13} warnings=${14}
  local -a tmparr tmparr1 tmparr2
  local -A rangeconsistency
  general["rignr"]="$1"
  
  # Check if rigctl is available
  if ! command -v rigctl &>/dev/null; then
    echo "Error: rigctl not found in PATH. Please install hamlib." >&2
    return 1
  fi
  
  # Read capabilities line by line, to make sure we also can detect unhandled things.
  # If we wold just grep for specific lines, we wouldn't know what we are missing to evaluate.
  while IFS="" read -r line; do
# Detect indented blocks like extra functions, levels, parameters, memories etc.
# Note that in some hamlib versions, these lines may also contain additional info, not just headings.
    if [[ "$line" =~ ^Extra\ functions: ]]; then
      indentation="functions" 
      continue
    elif [[ "$line" =~ ^Extra\ levels: ]]; then
      indentation="levels" 
      continue
    elif [[ "$line" =~ ^Extra\ parameters: ]]; then
      indentation="parameters" 
      # ToDo: process rest of line after colon.
      continue
    elif [[ "$line" =~ ^Memories: ]]; then
      indentation="memories" 
      # ToDo: process rest of line after colon.
      continue
    elif [[ "$line" =~ ^TX\ ranges ]]; then
      indentation="txranges" 
      # ToDo: process rest of line after colon.
      continue
    elif [[ "$line" =~ ^RX\ ranges ]]; then
      indentation="rxranges" 
      # ToDo: process rest of line after colon.
      continue
    elif [[ "$line" =~ ^Tuning\ steps ]]; then
      indentation="tuningsteps" 
      # ToDo: process rest of line after colon.
      continue
    elif [[ "$line" =~ ^Filters: ]]; then
      indentation="filters" 
      # ToDo: process rest of line after colon.
      continue
    elif [[ "$line" =~ ^Bandwidths: ]]; then
      indentation="bandwidths" 
      # ToDo: process rest of line after colon.
      continue
    elif [[ ! "$line" =~ ^[[:space:]] ]]; then
      indentation=""
    fi
# Extra functions
    if [[ "$indentation" == "functions" && "$line" =~ ^[[:space:]] ]]; then
      if [[ ( ${rigcap_exclude_extra} -ne 1 ) && ( ! "$line" =~ : ) ]]; then
        read -r tmp <<<"$line"
        general["functions_get"]+=" $tmp"
        general["functions_set"]+=" $tmp"
        functions[$tmp]+="getset"
      fi
      continue
# Extra levels and parameters
    elif [[ "$indentation" =~ levels|parameters && "$line" =~ ^[[:space:]] ]]; then
      if [[ ${rigcap_exclude_extra} -eq 1 ]] ; then
        # Do nothing
        true
      elif [[ ! "$line" =~ : ]]; then
        read -r tmp1 <<<"$line" # name
      elif [[ "$line" =~ Type:\ STRING ]]; then
        # We just can get string extra parameters, not set them.
        # Restriction due to input devices. No keyboard, just numpad or MIDI.
        general["${indentation}_get"]+=" $tmp1"
        if [[ $indentation =~ levels ]] ; then
          levels[$tmp1]+="get"
        else
          params[$tmp1]+="get"
        fi
        bounds[$tmp1]="string"
      elif [[ "$line" =~ Type:\ (CHECKBUTTON|BUTTON) ]]; then
        if [[ -n "${rangeconsistency[$tmp1]}" && "${rangeconsistency[$tmp1]}" != "0:1:1" ]]; then
          echo "${general["vendor"]} ${general["model"]}, ${general["rignr"]}:"
          echo "Range inconsistency for extra ${indentation::-1} CHECKBUTTON $tmp1. Was already stored with '${rangeconsistency[$tmp1]}'." 
          exit 1
        fi
        rangeconsistency[$tmp1]="0:1:1"
        general["${indentation}_get"]+=" $tmp1"
        general["${indentation}_set"]+=" $tmp1"
        if [[ $indentation =~ levels ]] ; then
          levels[$tmp1]+="getset"
        else
          params[$tmp1]+="getset"
        fi
        bounds[$tmp1]="mappedvalues"
        bounds[$tmp1:names]="off on"
        bounds[$tmp1:values]="0 1"
        bounds[$tmp1:n2v:off]="0"
        bounds[$tmp1:n2v:on]="1"
        bounds[$tmp1:v2n:0]="off"
        bounds[$tmp1:v2n:1]="on"
      elif [[ "$line" =~ Range: ]]; then
        tmparr=( $(echo "$line" | sed 's#\(\.\.\|/\)# \1 #g') )
        if [[ "${tmparr[2]}" == ".."
          && "${tmparr[4]}" == "/"
        ]]; then
          tmp2="${tmparr[1]}" # min
          tmp3="${tmparr[3]}" # max
          tmp4="${tmparr[5]}" # resolution
          # Check if another level or parameter with the same name is already registered with a different value range.
          # We expect that value ranges for set and get are the same and that parameters and levels do not have the same name.
          if [[ -n "${rangeconsistency[$tmp1]}" && "${rangeconsistency[$tmp1]}" != "$tmp2:$tmp3:$tmp4" ]]; then
            echo "${general["vendor"]} ${general["model"]}, ${general["rignr"]}:"
            echo "Range inconsistency for extra ${indentation::-1} $tmp1. Is '$tmp2:$tmp3:$tmp4' but was already stored with '${rangeconsistency[$tmp1]}'."
            exit 1
          fi
          rangeconsistency[$tmp1]="$tmp2:$tmp3:$tmp4"
          # Check if min/max is set or if both contain 0.
          if [[ ( ( ! "${tmp2//./}" =~ ^0+$ ) || ( ! "${tmp3//./}" =~ ^0+$ ) )
            && ( ! ${bounds[$tmp1]} =~ minmax )
          ]]; then
            bounds[$tmp1]+="minmax"
            bounds[$tmp1:min]=$(strip_trailing_zeros "$tmp2")
            bounds[$tmp1:max]=$(strip_trailing_zeros "$tmp3")
          fi
          # Check if resolution is not 0.
          if [[ ( ! "${tmp4//./}" =~ ^0+$ )
            && ( ! ${bounds[$tmp1]} =~ res )
          ]]; then
            bounds[$tmp1]+="res"
            bounds[$tmp1:res]=$(strip_trailing_zeros "$tmp4")
          fi
          # float or int
          xxx="${bounds[$tmp1:min]}${bounds[$tmp1:max]}${bounds[$tmp1:res]}"
          if [[ -z $xxx ]] ; then
            xxx="${tmp2}${tmp3}${tmp4}"
          fi
          if [[ ${bounds[$tmp1]} =~ string|values|int|float ]] ; then
            # float or int is already set or do not apply
            true
          elif [[ ( ! ${bounds[$tmp1]} =~ int ) && ( -n $xxx ) && ( ! $xxx =~ \. ) ]] ; then
            bounds[$tmp1]+="int"
          elif [[ ! ${bounds[$tmp1]} =~ float ]] ; then
            bounds[$tmp1]+="float"
          fi
          if [[ $indentation =~ levels ]] ; then
            levels[$tmp1]+="getset"
          else
            params[$tmp1]+="getset"
          fi
          general["${indentation}_get"]+=" $tmp1"
          general["${indentation}_set"]+=" $tmp1"
        else
          echo "${general["vendor"]} ${general["model"]}, ${general["rignr"]}:"
          echo "Unexpected 'Range' for extra ${indentation::-1} $tmp1 in '$line'."
          exit 1
        fi
      elif [[ "$line" =~ Values: ]]; then
        tmparr=( )
        tmp=$(echo "$line" | sed -e 's/\([^:"]\) /\1_/g' -e 's/^.*Values: //g' -e 's/\([0-9]\+\)=/tmparr[\1]=/g' -e 's/ /; /g')
        eval "$tmp"
        general["${indentation}_get"]+=" $tmp1"
        general["${indentation}_set"]+=" $tmp1"
        if [[ $indentation =~ levels ]] ; then
          levels[$tmp1]+="getset"
        else
          params[$tmp1]+="getset"
        fi
        bounds[$tmp1]="mappedvalues"
        bounds[$tmp1:names]="${tmparr[*]}"
        bounds[$tmp1:values]="${!tmparr[*]}"
        for i in ${!tmparr[@]} ; do
          bounds[$tmp1:v2n:$i]="${tmparr[$i]}"
          bounds[$tmp1:n2v:${tmparr[$i]}]="$i"
        done
      fi
      continue
# Ignore other indented content for now.
    elif [[ -n "$indentation" && "$line" =~ ^[[:space:]] ]]; then
      continue
    fi
# Ignore these lines, at least for now.
    if [[ -z "$line"
      || "$line" =~ ^Overall\ backend\ warnings:
      || "$line" =~ ^Caps\ dump\ for\ model:
      || "$line" =~ ^Hamlib\ version
      || "$line" =~ ^Backend\ version:
      || "$line" =~ ^Backend\ copyright:
      || "$line" =~ ^Backend\ status:
      || "$line" =~ ^Rig\ type:
      || "$line" =~ ^PTT\ type:
      || "$line" =~ ^DCD\ type:
      || "$line" =~ ^Port\ type:
      || "$line" =~ ^Serial\ speed:
      || "$line" =~ ^Write\ delay:
      || "$line" =~ ^Post\ (W|w)rite\ delay:
      || "$line" =~ ^Has\ targetable\ VFO:
      || "$line" =~ ^Has\ transceive:
      || "$line" =~ ^Targetable\ features:
      || "$line" =~ ^Has\ async\ data\ support:
      || "$line" =~ ^Spectrum
      || "$line" =~ ^Has[[:space:]]
    ]]; then
      continue
# Rig model name
    elif [[ "$line" =~ ^Model\ name: ]]; then
      read -r tmp tmp tmp <<<"$line"
      if [[ -z $tmp ]] ; then
        tmp="Generic"
      fi
      general["model"]="$tmp"
# Vendor name
    elif [[ "$line" =~ ^Mfg\ name: ]]; then
      read -r tmp tmp tmp <<<"$line"
      general["vendor"]="$tmp"
# Warnings
  elif [[ "$line" =~ Warning-- ]]; then
    warnings+=( "${line:10}" )
# Announce
    elif [[ "$line" =~ ^Announce: ]]; then
      read -r tmp tmp <<<"$line"
      general["announce"]="$tmp"
# RIT, XIT, IF-Shift
    elif [[ "$line" =~ ^Max\ (RIT|XIT|IF-SHIFT): ]]; then
      read -r tmp tmp1 tmp <<<"$line"
      tmp1=${tmp1:0:3}
      tmp1=${tmp1/IF-/IFSHIFT} # contains RIT, XIT or IFSHIFT
      read -r tmp2 tmp3 <<<"$(echo "$tmp" | sed -e 's#/+# #g' -e 's/k/*1000/g' -e 's/M/*1000000/g' -e 's/G/*1000000000/g' -e s#Hz#/1#g)"
      bounds[${tmp1}]=minmaxintunit
      bounds[${tmp1}:unit]=Hz
      bounds[${tmp1}:min]=$(echo "$tmp2" | bc)
      bounds[${tmp1}:max]=$(echo "$tmp3" | bc)
# Preamp, Attenuator
    elif [[ "$line" =~ ^(Preamp|Attenuator): ]]; then
      read -r tmp1 tmp2 <<<"$line"
      tmp1="${tmp1//:/}"
      tmp1="${tmp1^^}"
      if [[ $tmp1 =~ ^ATTEN ]]; then
        # Corresponding level for attenuator is just called ATT.
        tmp1="ATT"
      fi
      if [[ "$tmp2" == "None" ]]; then continue; fi
      tmp3="${tmp2//dB/}"
      bounds[${tmp1}]=mappedvaluesunit
      bounds[${tmp1}:unit]="dB"
      bounds[${tmp1}:names]="OFF $tmp2"
      bounds[${tmp1}:values]="0 $tmp3"
      for i in $tmp2 ; do
        bounds[${tmp1}:n2v:$i]="${i//dB/}"
        bounds[${tmp1}:v2n:${i//dB/}]="$i"
      done
      bounds[${tmp1}:n2v:OFF]="0"
      bounds[${tmp1}:v2n:0]="OFF"
# AGC levels
    elif [[ "$line" =~ ^AGC\ levels: ]]; then
      read -r tmp tmp tmp <<<"${line//=/ }"
      tmparr=( $tmp )
      tmp=${#tmparr[@]}
      tmparr1=()
      tmparr2=()
      for ((i=0; i<$tmp; i++)); do
         tmparr1+=( "${tmparr[i]}" )
         ((i++))
         tmparr2+=( "${tmparr[i]}" )
      done
      bounds["AGC"]=mappedvalues
      bounds["AGC:values"]="${tmparr1[*]}"
      bounds["AGC:names"]="${tmparr2[*]}"
      for i in ${!tmparr1[@]} ; do
        bounds["AGC:v2n:${tmparr1[$i]}"]="${tmparr2[$i]}"
        bounds["AGC:n2v:${tmparr2[$i]}"]="${tmparr1[$i]}"
      done
# Feature availability
    elif [[ "$line" =~ ^Can\ (Reset|Scan): ]]; then
      read -r tmp tmp1 tmp2 <<<"${line,,}"
      tmp1="${tmp1//:/}"
      if [[ "$tmp2" == "y" ]]; then
        features[$tmp1]="yes"
      fi
    elif [[ "$line" =~ ^Can\ (get|set|send|recv|stop|wait|decode|ctl)\ [A-Z,a-z]+ ]]; then
      read -r tmp tmp1 tmp <<<"${line,,}"
      tmp="${tmp// /}"
      tmp="${tmp//:/}"
      read -r tmp2 tmp3 <<<"$tmp"
      if [[ "$tmp2" == "mem/vfo" ]]; then
        tmp2="memvfo"
      fi
      if [[ "$tmp3" == "y" ]]; then
        features[$tmp2]+="$tmp1"
      fi
# Modes
    elif [[ "$line" =~ ^Mode\ list: ]]; then
      read -r tmp tmp tmp <<<"$line" # tmp now contains the modes.
      modeslist=( $tmp )
# CTCSS
    elif [[ "$line" =~ ^CTCSS: ]]; then
      tmp=$(echo "$line" | sed 's/\(CTCSS: *\)\|\( Hz.*$\)\|\.//g')
      if [[ -n "$tmp" && ! "$tmp" =~ None ]]; then
        ctcss=( $tmp )
      fi
# DCS
    elif [[ "$line" =~ ^DCS: ]]; then
      tmp=$(echo "$line" | sed 's/\(DCS: *\)\|\(,.*$\)\|\.//g')
      if [[ -n "$tmp" && ! "$tmp" =~ None ]]; then
        dcs=( $tmp )
      fi
# VFO list
    elif [[ "$line" =~ ^VFO\ list: ]]; then
      read -r tmp tmp tmp <<<"$line"
      vfos=( $tmp )
# Banks
    elif [[ "$line" =~ Number\ of\ banks: ]]; then
      read -r tmp tmp tmp tmp <<<"$line"
      general["banks"]="$tmp"
# Memory name size
    elif [[ "$line" =~ Memory\ name\ desc\ size: ]]; then
      read -r tmp tmp tmp tmp tmp <<<"$line"
      general["memnamedescsize"]="$tmp"
# Functions
    elif [[ "$line" =~ ^(Get|Set)\ functions: ]]; then
      read -r tmp1 tmp tmp2 <<<"$line"
      tmp1="${tmp1,,}"
      general["functions_$tmp1"]="$tmp2"
      for i in $tmp2 ; do
        functions["$i"]+="$tmp1"
      done
# VFO Ops
    elif [[ "$line" =~ ^VFO\ Ops: ]]; then
      read -r tmp tmp tmp <<<"$line"
      vfo_ops=( $tmp )
# Scan Ops
    elif [[ "$line" =~ ^Scan\ Ops: ]]; then
      read -r tmp tmp tmp <<<"$line"
      scan_ops=( $tmp )
# Levels and Parameters
    elif [[ "$line" =~ ^(Get|Set)\ (level|parameters): ]]; then
      # Read get/set into tmp1, level/parameters into tmp2 and rest into tmp.
      read -r tmp1 tmp2 tmp <<<"$line"  
      tmp1="${tmp1,,}" # lowercase
      tmp2="${tmp2//s:/}"
      tmp2="${tmp2//:/}"
      tmparr=( $(echo "$tmp" | sed 's#\((\|\.\.\|/\|)\)# \1 #g') )
      (( i=0 ))
      while (( i<${#tmparr[@]} )); do
        if [[ "${tmparr[i+1]}" == "("
          && "${tmparr[i+3]}" == ".."
          && "${tmparr[i+5]}" == "/"
          && "${tmparr[i+7]}" == ")"
        ]]; then
          tmp3="${tmparr[i]}" # name
          tmp4="${tmparr[i+2]}" # min
          tmp5="${tmparr[i+4]}" # max
          tmp6="${tmparr[i+6]}" # resolution
          # Check if another level or parameter with the same name is already registered with a different value range.
          # We expect that value ranges for set and get are the same and that parameters and levels do not have the same name.
          if [[ -n "${rangeconsistency[$tmp3]}" && "${rangeconsistency[$tmp3]}" != "$tmp4:$tmp5:$tmp6" ]]; then
            echo "${general["vendor"]} ${general["model"]}, ${general["rignr"]}:"
            echo "Range inconsistency for $tmp1 $tmp2 $tmp3. Is '$tmp4:$tmp5:$tmp6' but was already stored with '${rangeconsistency[$tmp3]}'."
            exit 1
          fi
          rangeconsistency[$tmp3]="$tmp4:$tmp5:$tmp6"
          if [[ ( ( ! "${tmp4//./}" =~ ^0+$ ) || ( ! "${tmp5//./}" =~ ^0+$ ) )
            && ( ! ${bounds[$tmp3]} =~ minmax )
          ]]; then
            bounds[$tmp3]+="minmax"
            bounds[$tmp3:min]=$(strip_trailing_zeros "$tmp4")
            bounds[$tmp3:max]=$(strip_trailing_zeros "$tmp5")
          fi
          # Check if resolution is not 0.
          if [[ ( ! "${tmp6//./}" =~ ^0+$ )
            && ( ! ${bounds[$tmp3]} =~ res )
          ]]; then
            bounds[$tmp3]+="res"
            bounds[$tmp3:res]=$(strip_trailing_zeros "$tmp6")
          fi
          xxx="${bounds[$tmp3:min]}${bounds[$tmp3:max]}${bounds[$tmp3:res]}"
          if [[ -z $xxx ]] ; then
            xxx="${tmp4}${tmp5}${tmp6}"
          fi
          if [[ ${bounds[$tmp3]} =~ string|values|float|int ]] ; then
            # float or int is already set or do not apply
            true
          elif [[ ( ! ${bounds[$tmp3]} =~ int ) && ( -n $xxx ) && ( ! $xxx =~ \. ) ]] ; then
            bounds[$tmp3]+="int"
          elif [[ ! ${bounds[$tmp3]} =~ float ]] ; then
            bounds[$tmp3]+="float"
          fi
          case $tmp2 in
            level)
              levels[$tmp3]+="$tmp1"
              ;;
            parameter)
              params[$tmp3]+="$tmp1"
              ;;
            *)
              echo "${general["vendor"]} ${general["model"]}, ${general["rignr"]}:"
              echo "Unexpected keyword '$tmp2' for $tmp1 $tmp2 $tmp3."
              exit 1
              ;;
          esac
          general["${tmp2}s_${tmp1}"]+="$tmp3 "
          (( i+=8 ))
        elif [[ "${tmparr[i+1]}" == "("
          && "${tmparr[i+3]}" == ")"
        ]]; then
          tmp3="${tmparr[i]}" # name
          tmp4="${tmparr[i+2]}" # content
          if [[ -n "${rangeconsistency[$tmp3]}" && "${rangeconsistency[$tmp3]}" != "$tmp4" ]]; then
            echo "${general["vendor"]} ${general["model"]}, ${general["rignr"]}:"
            echo "Range inconsistency for $tmp1 $tmp2 $tmp3. Is '$tmp4' but was already stored with '${rangeconsistency[$tmp3]}'."
            exit 1
          fi
          rangeconsistency[$tmp3]="$tmp4"
          if [[ ! ${bounds[$tmp3]} =~ string ]] ; then
            bounds[$tmp3]+="string"
          fi
          bounds[$tmp3:strings]="$tmp4"
          case $tmp2 in
            level)
              levels[$tmp3]+="$tmp1"
              ;;
            parameter)
              params[$tmp3]+="$tmp1"
              ;;
            *)
              echo "${general["vendor"]} ${general["model"]}, ${general["rignr"]}:"
              echo "Unexpected keyword '$tmp2' for $tmp1 $tmp2 $tmp3."
              exit 1
              ;;
          esac
          general["${tmp2}s_${tmp1}"]+="$tmp3 "
          (( i+=4 ))
        else
          echo "${general["vendor"]} ${general["model"]}, ${general["rignr"]}:"
          echo "Unexpected $tmp1 $tmp2 capability at entry $(( i/8 + 1 )) in '$tmp'."
          exit 1
        fi
      done
# Unhandled lines
    elif [[ $show_unhandled -gt 0 ]]; then
      if [[ $show_unhandled -eq 1 ]]; then
        echo "Unhandled capability lines for ${general["vendor"]} ${general["model"]}, ${general["rignr"]}:"
        show_unhandled=2
      fi
      echo "  Unhandled: '$line'"
    fi
  done <<<"$(rigctl -m "$1" --dump-caps 2>&1 | tr -d '\r')"
  for i in "${!features[@]}"; do
    if [[ "${features[$i]}" =~ setget ]]; then
      features[$i]=getset
    elif [[ "${features[$i]}" =~ recvsend ]]; then
      features[$i]=sendrecv
    fi
  done
  # Fake we have at least one getonly and setonly function.
  if false ; then
    # Pretend RIT is getonly (readonly)
    functions["RIT"]=${functions["RIT"]//set/}
    general["functions_set"]=${general["functions_set"]//RIT/}
    # Pretend XIT is setonly.
    functions["XIT"]=${functions["XIT"]//get/}
    general["functions_get"]=${general["functions_get"]//XIT/}
  fi # End fake
  general["functions"]=general["functions_get"]
  for i in ${general["functions_get"]}; do
    if [[ "${functions[$i]}" == "get" ]]; then
      general["functions_getonly"]+="$i "
    else
      general["functions_getset"]+="$i "
    fi
  done
  for i in ${general["functions_set"]}; do
    if [[ "${functions[$i]}" == "set" ]]; then
      general["functions"]+=" $i"
      general["functions_setonly"]+="$i "
    fi
  done
  general["levels"]=general["levels_get"]
  for i in ${general["levels_get"]}; do
    if [[ "${levels[$i]}" == "get" ]]; then
      general["levels_getonly"]+="$i "
    else
      general["levels_getset"]+="$i "
    fi
  done
  for i in ${general["levels_set"]}; do
    if [[ "${levels[$i]}" == "set" ]]; then
      general["levels"]+=" $i"
      general["levels_setonly"]+="$i "
    fi
  done
  general["parameters"]=general["parameters_get"]
  for i in ${general["parameters_get"]}; do
    if [[ "${params[$i]}" == "get" ]]; then
      general["parameters_getonly"]+="$i "
    else
      general["parameters_getset"]+="$i "
    fi
  done
  for i in ${general["parameters_set"]}; do
    if [[ "${params[$i]}" == "set" ]]; then
      general["parameters"]+=" $i"
      general["parameters_setonly"]+="$i "
    fi
  done
}

# If set to 1, do not evaluate extra functions, levels and parameters.
# This is done because it seems that current hamlib implementation doesn't
# support accesing extra things via network protocol on dummy transceiver backend.
# This leads to errors when doing demos with dummy transceiver.
if [[ ! -v rigcap_exclude_extra ]] ; then
  rigcap_exclude_extra=0
fi

# Decclare global variables for storing rig capabilites 
# and evaluate rig capabilities.
# Global variable "model" with RIG model number must be set before. 
get_rig_capabilities() {
  # shellcheck disable=SC2034
  declare -ag rigcap_ctcss rigcap_dcs rigcap_modes rigcap_vfos rigcap_vfo_ops rigcap_scan_ops rigcap_warnings
  declare -Ag rigcap_functions rigcap_levels rigcap_parameters rigcap_general rigcap_bounds rigcap_features
  internal_get_capabilities $model rigcap_general rigcap_bounds rigcap_features rigcap_ctcss rigcap_dcs rigcap_modes rigcap_vfos rigcap_vfo_ops rigcap_scan_ops rigcap_functions rigcap_levels rigcap_parameters rigcap_warnings
}

# Seems like output from --dump-caps doesn't permit us to decide between int and float
# for levels and parameters reliably. So we ned to get a value for each and
# see if it contains decimal point.
# Only go from int to float, not vice versa.
adjust_rig_capabilities() {
  local type lp cmd v i num numadj
  local -a cmdarr varr lparr
  num=0
  numadj=0
  for type in level parameter ; do
    cmd=${type:0:1}
    cmdarr=( )
    varr=( )
    lparr=( )
    for lp in ${rigcap_general["${type}s_get"]}; do
      if [[ ${rigcap_bounds[$lp]} =~ int ]]; then
        (( num++ ))
        lparr+=( $lp )
        cmdarr+=( $cmd $lp )
      fi
    done
    ###echo "XXX ${type}s names: ${lparr[*]}"
    # Use tr to remove carriage returns on Windows
    varr=( $(rigctl -m 2 -r "$host:$port" ${cmdarr[@]} 2>&1 | tr -d '\r') )
    ###echo "XXX ${type}s values: ${varr[*]}"
    for i in ${!lparr[@]}; do
      lp=${lparr[$i]}
      v=${varr[$i]}
      if [[ $v =~ \. ]]; then
        (( numadj++ ))
        ###echo "XXX adjust $type $lp from int to float"
        rigcap_bounds["$lp"]="${rigcap_bounds["$lp"]//int/float}"
      fi
    done
  done
  ###echo "XXX adjusted $numadj of $num int values to float."
}

# Check if rig can set/get/send/recv/ctrl a feature/function/level/parameter.
# Parameters:
# verb: Action that shall be checked, e.g. get, set.
# type: oe of fuction, feature, level, parameter.
# name: Name of the function/level/parameter/feature.
# Returns 0 if action is possible, 1 otherwise.
rig_can() {
  declare -n check="rigcap_${2}s"
  ###echo "XXX: rig_can $1 $2 $3: ${check[$3]}"
  if [[ ${check[$3]} =~ $1 ]]; then
    return 0
  else
    return 1
  fi
}

# Like rig_can, but print message if action is not possible.
announce_rig_can() {
  if rig_can "$@" ; then
    return 0
  else
    echo "${1^} $3 is not supported."
    return 1
  fi
}

# Check if rig value (level or parameter) has a certain property like
# min, max, res, mappedvalues, values or string.
# Parameters: name prop
rig_value_has() {
  if [[ ${rigcap_bounds[$1]} =~ $2 ]]; then
    return 0
  else
    return 1
  fi
}

# Retrieve level or parameter from RIG
# Parameters:
# type: Either level or parameter.
# name: level/parameter name.
announce_rig_get_lp() {
  local retval tmp perc
  if ! announce_rig_can get $1 $2 ; then
    return 1
  elif [[ $1 == "parameter" ]] ; then  
    retval=$(rigctl -m 2 -r "$host:$port" p "$2" 2>&1 | tr -d '\r')
  else
    retval=$(rigctl -m 2 -r "$host:$port" l "$2" 2>&1 | tr -d '\r')
  fi
  # Handle the following types:
  # - mappedvalues[unit]
  # - [minmax][res](float|int)[unit]
  # - string
  # int doesn't require special treatment.
  ###echo "XXX ${rigcap_bounds[$2]}"
  if [[ ${rigcap_bounds[$2]} =~ mappedvalues ]]; then
    tmp=${rigcap_bounds[$2:v2n:${retval}]}
    if [[ -n $tmp ]]; then
      ###echo "XXX mappedvalue"
      retval=$tmp
    fi
  elif [[ ${rigcap_bounds[$2]} =~ float ]]; then
    ###echo "XXX float $2 $retval"
    retval="$(strip_trailing_zeros_float "$retval")"
    if [[ ( ${rigcap_bounds[$2:min]} -eq 0 ) && ( ${rigcap_bounds[$2:max]} -eq 1 ) ]]; then
      perc=", $(echo "valuetopercentage(${retval},${rigcap_bounds[$2:min]},${rigcap_bounds[$2:max]})" | $funcdir/levelsandparams.bc)%"
    fi
  fi
  if [[ ( ${rigcap_bounds[$2]} =~ unit ) && ( $retval =~ ^[-+0-9] ) && ( ! $retval =~ ${rigcap_bounds[$2:unit]}$ ) ]]; then
    # Add unit if this is a numeric value and dosn't end with a unit although it should.
    ###echo "XXX unit"
    retval+="${rigcap_bounds[$2:unit]}"
  fi
  echo "$2 = ${retval//_/ }${perc}" # Replace _ with space.
  return 0
}

# Send level or parameter to RIG
# Parameters:
# type: Either level or parameter.
# name: level/parameter name.
# midival: MIDI controller value.
# midicmd: MIDI command, second parameter from MIDI map.
announce_rig_set_lp() {
  if ! announce_rig_can set $1 $2 ; then
    return 1
  fi
  local i newval newvaltxt
  # Prepare and cache menu entries and values. 
  declare -g last_set_lp last_set_lp_type
  declare -ag set_lp_names set_lp_values
  if [[ ( ${last_set_lp_type} != $1 ) || ( ${last_set_lp} != $2 ) ]]; then
    last_set_lp_type=$1
    last_set_lp=$2
    set_lp_names=( )
    set_lp_values=( )
    if [[ ${rigcap_bounds[$2]} =~ string ]]; then
      set_lp_names=( ${rigcap_bounds[$2:strings]} )
      set_lp_values=( ${rigcap_bounds[$2:strings]} )
    else
      set_lp_names=( ${rigcap_bounds[$2:names]} )
      set_lp_values=( ${rigcap_bounds[$2:values]} )
    fi
    for i in ${!set_lp_names[@]} ; do
      set_lp_names[$i]="${set_lp_names[$i]//_/ }"
    done
  fi
  if [[ ( $3 ) && ( ${#set_lp_names[@]} -ge 0  ) ]]; then
# ToDo
    # strings and mappedvalues[unit] for MIDI
    echo "Not implemented for MIDI yet."
    return 1
  elif [[ ${#set_lp_names[@]} -gt 0 ]]; then
    # strings and mappedvalues[unit] for menu
    show_menu --retvar "$2" set_lp_names "$(t MSG_NEW_VALUE_PROMPT)" i
    if [[ -n $i ]]; then
      newvaluetxt=${set_lp_names[$i]}
      newvalue=${set_lp_values[$i]}
    else
      # User didn't want to set a new value
      return 0
    fi
# ToDo: handle [minmax][res](float|int)[unit]
  elif [[ $3 ]]; then # MIDI
    echo "Not implemented for MIDI yet."
    return 1
  else
    echo "Not implemented for menu yet."
    return 1
  fi
  # send value to rig
  i=${last_set_lp_type:0:1}
  i=${i^^}
  if ! rigctl -m2 -r "$host:$port" "$i" "$2" "$newvalue" ; then
    echo "Error while setting $2 to ${newvaluetxt}."
  fi
  return 0
}
