if ! announce_rig_can getset feature func ; then
  return 0
fi

# Build the functions list by querying the backend for supported functions. 
if [[ ! -v functions ]]; then
  functions=( ${rigcap_general[functions_getonly]} ${rigcap_general[functions_getset]} ${rigcap_general[functions_setonly]} )
  functions_get="${rigcap_general[functions_getonly]} ${rigcap_general[functions_getset]}"
fi
function_states=( $(rigctl -m 2 -r "$host:$port" $(for f in ${functions_get}; do echo "u $f"; done)) )

function_select_entry() {
  if [[ -n "${function_states[$1]}" ]] ; then
    echo "${functions[$1]} ($(humanize_status "${function_states[$1]}"))"
  else
    echo "${functions[$1]}"
  fi
}

function_select_handler() {
  last_function=${functions[$1]}
  shift $# # Clear all parameters. Otherwise they are given to the sourced script.
  source "$funcdir/functions/function_toggle"
  # Function states are updated when in function_select_entry.
  return 0
}

if [[ $1 ]]; then #Triggered with parameter
# We assume that the user selects the desired function with a rotary encoder.
# So we put name and status of the function in charge into two variables
# What ever kind of midi controller the user has: These variables can be used to toggle the function on or off. Due to the sourcing natureof the whole project, the variables are available from everywhere.
  if validate_midi_value "$@" functions func_midi_result; then
    function_select_handler $func_midi_result
  fi
else # Called from keyboard, show functions list and ask for selection.
  show_menu "Functions:" functions 'Function?: ' function_select_handler function_select_entry
fi
