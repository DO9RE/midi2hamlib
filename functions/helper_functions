# Function for formatting human input frequencies into the hamlib needed format
# We assume a base of MHz, therefore we multiply with 1000000
# We switch eventually commas with decimal points, using SED.
re_format_frequency() {
  local frequency=$1
  frequency=$(echo "$frequency * 1000000 /1" | sed 's/,/./g' | bc)
  echo $frequency
}

# Function for stripping leading zeros and maybe also decimal point.
# This also replaces ',' by '.'.
strip_trailing_zeros() {
	echo $1 | sed 's/,/./g; s/\(\.[1-9]\+\)0*$/\1/g; s/\.0*$//g'
}
 
# Function for formatting frequencies output more human friendly
format_frequency() {
  local frequency=$1
  local power=""

  if (( frequency >= 1000000000 )); then
    frequency=$(echo "scale=9; $frequency / 1000000000" | bc)
    power="GHz"
  elif (( frequency >= 1000000 )); then
    frequency=$(echo "scale=6; $frequency / 1000000" | bc)
    power="MHz"
  elif (( frequency >= 1000 )); then
    frequency=$(echo "scale=3; $frequency / 1000" | bc)
    power="kHz"
  else
    power="Hz"
  fi
  # Output Frequency, remove trailing 0s or the whole decimal point if needed and add the power in Hz.
  echo "$(strip_trailing_zeros $frequency) $power"
}

function multiply_and_format { # expects a number and its multiplier. Returns the Number without the decimal point.
  local number=$1
  local multiplier=$2
  local result=$(echo "$number * $multiplier" | bc)
  local formatted_result=$(strip_trailing_zeros $result)
  echo $formatted_result
}

# ${#array[@]} to determine an arrays length in elements.
# Use this to restrict a midi controllers range to the given range of an options array for example.
function apply_modulo {
  local value=$1
  local max_value=$2
  local result=$((value % max_value))
  echo $result
}

# Use this for example, if you have a long fader path and a little list of possible values. The overall maximum fader value is divided by the possible options to create zones. Then, each fader value is checked, in which zone it is.
function fader_to_zones {
  local fader_value=$1
  local num_states=$2
  local zone_size=$((128 / num_states)) # we say, the fader has 128 possible values, maybe this changes later.
  local state=$((fader_value / zone_size))
  echo $state
}

function get_current_mode {
# Return only the mode name without the passband
  echo $(rigctl -m 2 -r $host:$port m | head -n 1)
}

# Function for use with the transceiver functions.
# Convert the status_last_function into human friendly on of texts
humanize_status() {
  local status=$1
  echo "$status" | sed -e 's/0/off/g' -e 's/1/on/g'
}

humanize_ctcss() {
   ctcss=$1
   echo "scale=1;${ctcss}/10" | bc | sed -e 's/^0$/off/g'
}

show_help() {
  echo "Usage: $0 [OPTIONS]"
  echo
  echo "Options:"
  echo "  -c, --config-file path_to_alternative_configuration/file.conf"
  echo "  -h, --help        Show this help"
}

# Read input and validate it.
# Accepts numbers between 0 and a given maximum.
# Prints an error message if input is invalid and returns 2.
# Returns 1 when input in empty, but doesn't print an error. Can be used for repeating menu output.
# Returns 0 if input is valid.
# Exits with errorcode 1 if parameters are not supplied or do not make sense.
# Syntax: read_and_validate prompt maxvalue varname
read_and_validate() {
  if [[ -z "$1" ]] ; then 
    echo "No prompt given for read_and_validate."
    exit 1 
  fi
  if [[ -z "$2" || $2 -lt 0 ]] ; then 
    echo "No maximum value or negative value given for read_and_validate."
    exit 1 
  fi
  if [[ -z "$3" ]] ; then 
    echo "No varname given for read_and_validate."
    exit 1 
  fi
  local -n result=$3
  read -rp "$1" result
  if [[ -z "$result" ]]; then
    return 1
  elif ! [[ "$result" =~ ^[0-9]+$ ]] ; then
    echo "Invalid input. Please enter a number only using digits 0 to 9."
    return 2
  elif [[ $result -lt 0 || $result -gt $2 ]]; then
    echo "Input out of range. please enter a number between 0 and $2."
    return 2
  fi
  return 0
}

# Like read_and_validate, but derives the maximum value from an array given by its name.
# Please make sure that the array is zero-based. The maximum value is calculated
# from the number of elements in the array.
# Syntax: read_and_validate prompt arrname varname
read_and_validate_arr_0() {
  local -n ravarr=$2
  local maxval=$((${#ravarr[@]}-1))
  read_and_validate "$1" $maxval $3
  return $?
}

# Like read_and_validate_arr_0, but adds adds 1 to maximum value.
# This is used if the array for the menu entries is 1-based.
# Syntax: read_and_validate prompt arrname varname
read_and_validate_arr_1() {
  local -n ravarr=$2
  local maxval=${#ravarr[@]}
  read_and_validate "$1" $maxval $3
  return $?
}

is_process_running_for_user() {
  local process_name="$1"
  local user_name="$2"

  if ps -u "$user_name" -f | grep -v grep | grep "$process_name" > /dev/null; then
    return 0
  else
    return 1
  fi
}

# Display a menu with title and elements from an array.
# the elements from the zero-based array are numbered beginning with 1.
# Index shifting is performed transparently, so the selection is again zero-based and can 
# directly be used to point into the array.
# parameters:
# --vartitle: If set as first parameter, the title is interpreted as a 
#   variable containing the actual menu title text. So you can change the
#   menu title dynamically on every menu chycle. Used for main menu.
# title: The menu title that is displayed above. Either a variable or string.
# entries: The name of the array that holds the menu entries.
# prompt: Menu prompt.
# selection_handler: Name of a function that shall be called with the index of the selected entry.
#   This is called, not sourced, as it is assumed to be a function.
#   If the function returns 0, the menu keeps displayed and asks for selections.
#   Otherwise the menu exits.
# entry_text_handler: optional handler that gets the zero-based index as
#   input and shall provide the entry text on stdout.
# The function returns when 0 is entered to leave the menu.
show_menu() {
  local is_vartitle=0
  if [[ "$1" == "--vartitle" ]]; then
    is_vartitle=1
    shift 1
  fi
  if [[ -z $1 ]]; then
    echo "No menu title given in show_menu."
    exit 1
  fi
  if [[ $is_vartitle -eq 1 ]]; then
    local -n title=$1
  else
    local title="$1"
  fi
  if [[ ! -v $2 ]]; then
    echo "No variable with menu entries given in show_menu."
    exit 1
  fi
  local -n show_menu_entries=$2
  local prompt="$3"
  if [[ -z $prompt ]]; then
    prompt="And now?: ";
  fi
  if [[ -z $4 ]]; then
    echo "No selection handler given in show_menu."
    exit 1
  fi
  local selection_handler=$4
  local entry_text_handler
  if [[ -n $5 ]]; then
    entry_text_handler=$5
  fi
  if [[ $# -gt 5 ]]; then
    echo "Too many parameters given to show_menu."
    exit 1
  fi
  # remove all positional parameters to avoid passing them accidentally to sourced scripts or functions.
  shift $#
  # start with actual menu
  local selection
  while true; do
    if [[ -n "$title" ]]; then
      echo -e "\n${title}"
    else
      echo ""
    fi
    for index in "${!show_menu_entries[@]}"; do
      if [[ -z $entry_text_handler ]]; then
        echo "$(($index+1)): ${show_menu_entries[$index]}"
      else
        echo "$(($index+1)): $(${entry_text_handler} $index)"
      fi
    done
    if ! read_and_validate_arr_1 "$prompt" show_menu_entries selection; then
      continue;
    fi
#   Exit functions menu when 0 is issued or if selection handler returns non-zero.
    if [[ $selection -eq 0 ]]; then
      break
    elif ! ${selection_handler} $((${selection}-1)) ; then
      break
    fi
  done
}
