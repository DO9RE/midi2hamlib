#!/usr/bin/bc -q
define void setupforint() {
  scale=0
}

define void setupforfloat() {
  scale=6
}

define void setscale(min, max, res) {
  if (scale < scale(min)) scale=scale(min)
  if (scale < scale(max)) scale=scale(max)
  if (scale < scale(res)) scale=scale(res)
}

define isinrange(value, min, max) {
  ((value >= min) && (value <= max))
}

define adjustvalueminmax(value, min, max) {
  if (value <= min) min else if (value >= max) max else value
}

define percentagetovalue(perc, min, max) {
  auto value
  if (perc<=0) {
    min
  } else if (perc>=100) {
    max
  } else {
    value=min+(max-min)*perc/100
    adjustvalueminmax(value,min,max)
  }
}

# Converts a value into a percentage relative to min and max.
# Returns integer part of percentage.
define valuetopercentage(value, min, max) {
  auto oldscale, retval
  oldscale=scale
  setupforfloat()
  retval=(value-min)/(max-min)*100
  scale=0
  retval=retval/1
  scale=oldscale
  return retval
}

define percentagetovalue(perc, min, max) {
  auto oldscale, retval
  oldscale=scale
  setupforfloat()
  retval=min+perc*(max-min)
  scale=oldscale
  return retval
}

define coercevalue(value, isint, min, max, res) {
  auto hasminmax, hasres, oldscale, tmp, retval, offset, lower, upper, diffl, diffu
  hasminmax = ((min!=0) || (max!=0))
  hasres = (res!=0)
  if (hasminmax && (min>max)) {
    tmp=min
    min=max
    max=tmp
  }
  if (res<0) res = -res
  if (hasminmax && (value<=min)) value=min
  if (hasminmax && (value>=max)) value=max
  oldscale=scale
  if (isint) setupforint() else setupforfloat()
  retval=value/1 # to adapt to scale
  if (hasres) {
    # In case 0 is not part of the valid value range, shift value to a 
    # 0-based range. Simplifies handling resolution.
    if (hasminmax && (min>0)) {
      offset=min
    } else if (hasminmax && (max<0)) {
      offset=max
    } else {
      offset=0
    }
    retval -= offset
    tmp=scale
    setupforint()
    lower=retval/res
    if ((lower>=0) && (retval>=0)) {
      upper=lower+1
    } else {
      upper=lower
      lower=upper-1
    }
    scale=tmp
    lower *= res
    upper *= res
    diffl=value-lower
    diffu=upper-value
    if (diffu<=diffl) retval=upper else retval=lower
    # Shift to valid range again.
    retval += offset
  }
  if (hasminmax && (retval<=min)) retval=min/1
  if (hasminmax && (retval>=max)) retval=max/1
  scale=oldscale
  return retval
}
