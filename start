#!/bin/bash
ensure_hamlib_windows_path() {
case "$(uname -s 2>/dev/null)" in
MINGW*|MSYS*|CYGWIN*)
local hamlib_bin_win="C:\\Program Files\\hamlib-w64-4.6.5\\bin"
local hamlib_bin_posix

hamlib_bin_posix="$(cygpath -u "$hamlib_bin_win" 2>/dev/null)"
if [ -n "$hamlib_bin_posix" ] && [ -d "$hamlib_bin_posix" ]; then
case ":$PATH:" in
*":$hamlib_bin_posix:"*) : ;;
*) export PATH="$PATH:$hamlib_bin_posix" ;;
esac
fi
;;
esac
}

ensure_bc_windowsish() {
if command -v bc >/dev/null 2>&1; then
return 0
fi

echo "bc ist nicht installiert."
echo -n "Jetzt installieren? [j/N] "
read -r ans
case "$ans" in
j|J|y|Y|yes|YES) ;;
*) echo "Abgebrochen."; return 1 ;;
esac

local uname_s
uname_s="$(uname -s 2>/dev/null || echo "")"

if command -v pacman >/dev/null 2>&1 && [[ "$uname_s" == MSYS* || "$uname_s" == MINGW* ]]; then
echo "MSYS2 erkannt. Installiere bc mit pacman..."
pacman -S --needed bc || return 1

elif command -v apt-get >/dev/null 2>&1 && grep -qiE "(microsoft|wsl)" /proc/version 2>/dev/null; then
echo "WSL erkannt. Installiere bc mit apt-get..."
sudo apt-get update && sudo apt-get install -y bc || return 1

elif command -v dnf >/dev/null 2>&1 && grep -qiE "(microsoft|wsl)" /proc/version 2>/dev/null; then
echo "WSL erkannt. Installiere bc mit dnf..."
sudo dnf install -y bc || return 1

else
echo "Konnte keine unterstÃ¼tzte Windows-Linux-Umgebung erkennen (MSYS2 oder WSL)."
echo "Bitte bc manuell installieren."
return 1
fi

command -v bc >/dev/null 2>&1
}

# Check, if BC is installed when we are on Windows
ensure_bc_windowsish

# First, check if hamlib is available
ensure_hamlib_windows_path
if [[ -z "$(command -v rigctl)" || -z "$(command -v rigctld)" ]]; then
  echo "rigctl or rigctld not found. Please install hamlib."
  exit 1
fi
# We have a few background processes running, exit these when CTRL+C is pressed
trap 'cleanup' INT TERM

cleanup() {
  echo "Cleaning up background processes..."
  pkill -P $$
  echo "Script terminated. All background processes have been stopped."
  exit 1
}

default_config_file="./settings/settings.conf"
funcdir="$(pwd)/functions"
source "$funcdir/rigcaps"
source "$funcdir/helper_functions"
# Process command line arguments
config_file=$default_config_file
if [[ -n $midi2hamlib_config_file ]] ; then
  config_file=$midi2hamlib_config_file
fi
while [[ $# -gt 0 ]]; do
  case $1 in
    -c|--config-file)
      config_file="$2"
      shift 2
      ;;
    -h|--help)
      show_help
      exit 0
      ;;
    *)
      echo "Unknown option: $1"
      show_help
      exit 1
      ;;
  esac
done

# Check, if config file exists:
if [[ ! -f "$config_file" ]]; then
  echo "Error! Configuration file '$config_file' does not exist."
  exit 1
else
  source "$config_file"
fi


# Check if a rig model was set.
if [[ $model -lt 1 ]]; then
  source "$basedir/additional_scripts/choose_rig"
fi

# Get rig capabilities
rigcap_exclude_extra=1 # Extra functions, levels and parameters seem not to work with rigctld.
get_rig_capabilities

# Check environment (Operating system)
check_environment

# Process rigctld options
declare -a rigctldoptions
if [[ -v model ]]; then rigctldoptions+=(-m "$model"); fi
if [[ -v port ]]; then rigctldoptions+=(-t "$port"); fi
if [[ -v device_path ]]; then rigctldoptions+=(-r "$device_path"); fi
if [[ -v serial_speed ]]; then rigctldoptions+=(-s "$serial_speed"); fi
rigctld "${rigctldoptions[@]}" &
unset rigctldoptions

# Wait for rigctld to start up.
maxretries=10
numretries=0
while true ; do
  (( numretries++ ))
  rigctl -m2 -r "$host:$port" "" >/dev/null 2>&1
  if [[ $? -eq 2 ]]; then
    if [[ $numretries -lt $maxretries ]]; then
      sleep 1
    else
      echo "Cannot connect to rigctld after trying $numretries times. Exiting."
      exit 1
    fi
  else
    ###echo "Conected to rigctld after trying $numretries times."
    break  
  fi
done
unset numretries maxretries

# Adjust rig capabilities, see doc for function.
adjust_rig_capabilities

# switch numpad to numbers
setleds +num

# Use MIDI devices?
if [[ $use_midi_device == "TRUE" ]]; then
  source "$basedir/midi/reader" &
fi

declare -a file_menu_entries
declare -a file_menu_actions

# clear
echo -e "$greeting \\n
Use 0 to return from a menu."
cd "$menudir"

# Function for Reading Folder Scripts and building Menu 
build_menu_from_files() {
# Resetting the menu arrays with every new menu to display
  unset file_menu_entries
  unset file_menu_actions
# Display the Menu Name from its name file
  # shellcheck disable=SC2034
  file_menu_title=$(cat "$(pwd)/name")
# Walk through the menu folder and build the menu from line 2 and 3 of each file
  local menu_name
  local file
  local menu_number=0
  # Use find instead of ls to better handle non-alphanumeric file names.
  # shellcheck disable=SC2012
  for file in $(ls | sort) ; do
    if [[ -f $file && ! $file == "name" ]]; then
      menu_name=$(sed -n '1p' "$file" | sed 's/# *//')
      eval "menu_name=\"$menu_name\""
      # shellcheck disable=SC2034
      file_menu_entries["$menu_number"]="$menu_name"
      file_menu_actions["$menu_number"]="$file"
      menu_number=$(( menu_number+1 ))
    fi
  done
}

file_menu_select() {
  local cmd=${file_menu_actions[$1]}
  shift $# # Clear all positional parameters to avoid passing them further on.
  source "$cmd"
  build_menu_from_files
  return 0
}

build_menu_from_files
while true; do
  show_menu --vartitle file_menu_title file_menu_entries 'And now? ' file_menu_select
# Menu was left with 0, so go up one level if possible.
  if [[ $(pwd) == "$menudir" ]]; then
    echo "Already at top level."
  elif [[ $(pwd) == "$basedir/menus/options" ]]; then
    cd "$menudir"
    build_menu_from_files
  else
    cd ..
    build_menu_from_files
  fi
done


