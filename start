#!/bin/bash
source "$(pwd)/additional_scripts/profiling"
funcdir="$(pwd)/functions"
# Early initialization of i18n
# Load i18n early
write_to_log "Start init i18n"
source "$funcdir/i18n"
write_to_log "End init i18n"

ensure_hamlib_windows_path() {
  case "$(uname -s 2>/dev/null)" in
  MINGW*|MSYS*|CYGWIN*)
    local hamlib_bin_win="C:\\Program Files\\hamlib-w64-4.6.5\\bin"
    local hamlib_bin_posix

    hamlib_bin_posix="$(cygpath -u "$hamlib_bin_win" 2>/dev/null)"
    if [ -n "$hamlib_bin_posix" ] && [ -d "$hamlib_bin_posix" ]; then
      case ":$PATH:" in
        *":$hamlib_bin_posix:"*) : ;;
        *) export PATH="$PATH:$hamlib_bin_posix" ;;
      esac
    fi
    ;;
  esac
}

ensure_bc_windowsish() {
  if command -v bc >/dev/null 2>&1; then
    return 0
  fi

  echo "$(t ERR_BC_NOT_INSTALLED)"
  echo -n "$(t ERR_INSTALL_NOW)"
  read -r ans
  case "$ans" in
    j|J|y|Y|yes|YES) ;;
    *) echo "$(t ERR_ABORTED)"; return 1 ;;
  esac

  local uname_s
  uname_s="$(uname -s 2>/dev/null || echo "")"

  if command -v pacman >/dev/null 2>&1 && [[ "$uname_s" == MSYS* || "$uname_s" == MINGW* ]]; then
    echo "$(t ERR_MSYS2_DETECTED)"
    pacman -S --needed bc || return 1

  elif command -v apt-get >/dev/null 2>&1 && grep -qiE "(microsoft|wsl)" /proc/version 2>/dev/null; then
    echo "$(t ERR_WSL_DETECTED)"
    sudo apt-get update && sudo apt-get install -y bc || return 1

  elif command -v dnf >/dev/null 2>&1 && grep -qiE "(microsoft|wsl)" /proc/version 2>/dev/null; then
    echo "$(t ERR_WSL_DNF_DETECTED)"
    sudo dnf install -y bc || return 1

  else
    echo "$(t ERR_NO_WINDOWS_LINUX)"
    echo "$(t ERR_INSTALL_BC_MANUALLY)"
    return 1
  fi

  command -v bc >/dev/null 2>&1
}

# Check, if BC is installed when we are on Windows
ensure_bc_windowsish

# First, check if hamlib is available
ensure_hamlib_windows_path
if [[ -z "$(command -v rigctl)" || -z "$(command -v rigctld)" ]]; then
  echo "$(t ERR_RIGCTL_NOT_FOUND)"
  exit 1
fi
# We have a few background processes running, exit these when CTRL+C is pressed
trap 'cleanup' INT TERM

cleanup() {
  echo "$(t MSG_CLEANING_UP)"
  pkill -P $$
  echo "$(t MSG_SCRIPT_TERMINATED)"
  exit 1
}

default_config_file="./settings/settings.conf"
source "$funcdir/rigcaps"
source "$funcdir/helper_functions"
# Process command line arguments
config_file=$default_config_file
if [[ -n $midi2hamlib_config_file ]] ; then
  config_file=$midi2hamlib_config_file
fi
while [[ $# -gt 0 ]]; do
  case $1 in
    -c|--config-file)
      config_file="$2"
      shift 2
      ;;
    -h|--help)
      show_help
      exit 0
      ;;
    *)
      echo "$(t ERR_UNKNOWN_OPTION "$1")"
      show_help
      exit 1
      ;;
  esac
done

# Check, if config file exists:
if [[ ! -f "$config_file" ]]; then
  echo "$(t ERR_CONFIG_NOT_EXIST "$config_file")"
  exit 1
else
  source "$config_file"
fi

# Load language based on config setting
write_to_log "Start load_language after config file."
load_language "$MIDI2HAMLIB_LANG"
write_to_log "End load_language after config file."


# Check if a rig model was set.
if [[ $model -lt 1 ]]; then
  source "$basedir/additional_scripts/choose_rig"
fi

# Get rig capabilities
rigcap_exclude_extra=1 # Extra functions, levels and parameters seem not to work with rigctld.
get_rig_capabilities

# Check environment (Operating system)
check_environment

# Process rigctld options
declare -a rigctldoptions
if [[ -v model ]]; then rigctldoptions+=(-m "$model"); fi
if [[ -v port ]]; then rigctldoptions+=(-t "$port"); fi
if [[ -v device_path ]]; then rigctldoptions+=(-r "$device_path"); fi
if [[ -v serial_speed ]]; then rigctldoptions+=(-s "$serial_speed"); fi
rigctld "${rigctldoptions[@]}" &
unset rigctldoptions

# Wait for rigctld to start up.
maxretries=10
numretries=0
while true ; do
  (( numretries++ ))
  rigctl -m2 -r "$host:$port" "" >/dev/null 2>&1
  if [[ $? -eq 2 ]]; then
    if [[ $numretries -lt $maxretries ]]; then
      sleep 1
    else
      echo "$(t ERR_CANNOT_CONNECT_RIGCTLD "$numretries")"
      exit 1
    fi
  else
    ###echo "Conected to rigctld after trying $numretries times."
    break  
  fi
done
unset numretries maxretries

# Adjust rig capabilities, see doc for function.
adjust_rig_capabilities

# switch numpad to numbers
setleds +num

# Use MIDI devices?
if [[ $use_midi_device == "TRUE" ]]; then
  source "$basedir/midi/reader" &
fi

declare -a file_menu_entries
declare -a file_menu_actions

# clear
echo -e "$greeting \\n
$(t MSG_USE_ZERO_TO_RETURN)"
cd "$menudir"

# Function for Reading Folder Scripts and building Menu 
build_menu_from_files() {
# Resetting the menu arrays with every new menu to display
  unset file_menu_entries
  unset file_menu_actions
# Display the Menu Name from its name file
  # shellcheck disable=SC2034
  file_menu_title=$(cat "$(pwd)/name")
  eval "file_menu_title=\"$file_menu_title\""
# Walk through the menu folder and build the menu from line 2 and 3 of each file
  local menu_name
  local file
  local menu_number=0
  # Use find instead of ls to better handle non-alphanumeric file names.
  # shellcheck disable=SC2012
  for file in $(ls | sort) ; do
    if [[ -f $file && ! $file == "name" ]]; then
      menu_name=$(sed -n '1p' "$file" | sed 's/# *//')
      eval "menu_name=\"$menu_name\""
      # shellcheck disable=SC2034
      file_menu_entries["$menu_number"]="$menu_name"
      file_menu_actions["$menu_number"]="$file"
      menu_number=$(( menu_number+1 ))
    fi
  done
}

file_menu_select() {
  local cmd=${file_menu_actions[$1]}
  shift $# # Clear all positional parameters to avoid passing them further on.
  source "$cmd"
  build_menu_from_files
  return 0
}

build_menu_from_files
while true; do
  show_menu --vartitle file_menu_title file_menu_entries "$(t MSG_AND_NOW)" file_menu_select
# Menu was left with 0, so go up one level if possible.
  if [[ $(pwd) == "$menudir" ]]; then
    echo "$(t MSG_ALREADY_AT_TOP_LEVEL)"
  elif [[ $(pwd) == "$basedir/menus/options" ]]; then
    cd "$menudir"
    build_menu_from_files
  else
    cd ..
    build_menu_from_files
  fi
done


